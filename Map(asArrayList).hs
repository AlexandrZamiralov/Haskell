import Data.Maybe(maybeToList)
data Map key value = Empty | Map key value (Map key value)
  deriving(Show,Eq)
-- ключ, значение, "ccылка на следующую", либо ничего

--Общие обозначения, встречающиеся в функциях
--mk = map key
--mv = map value
--m = children map
--k = key
--м = value

--функция получения значения по ключу
get :: Eq k => k -> Map k v -> Maybe (k,v)
get = get'
  where
    get' _ Empty = Nothing
    get' k (Map mk mv m)
      | k == mk = Just (mk, mv)
      | otherwise = get' k m
--получить хоть что из пустоты = ничего
--если не пустота, то проверим ключи
-- совпали -- вернем пару
-- не совпали -- ищем дальше

--расширенная функция получения всех пар ключ-значение
--по заданному списку ключей
gets :: Eq k => [k] -> Map k v -> [(k, v)]
gets _ Empty = []
gets [] _ = []
gets (x:xs) y = maybeToList(get x y) ++ gets xs y
--если кончились ключи или мы дошли до конца, то заканчиваем эту ветку
--если у нас еще есть ключи
-- то пробуем взять его из отображения, если получилось
-- то занесем в новый лист
-- если не получилось, то мэйбиЛист вернет []
--в любом случаем запустимся снова от укороченного листа ключей
--мы не можем сократить сократить количество запусков
-- так как ни лист ключей, ни отображение не упорядочены
--(поэтому запускаемся снова от y)

--функция помещения\замены пары ключ-значение
put :: Eq k => (k, v) -> Map k v -> Map k v
put = put'
  where
    put' (k, v) Empty = Map k v (Empty)
    put' (k, v) (Map mk mv m)
      | k == mk = Map mk v m
      | otherwise = Map mk mv (put (k, v) m)
--если надо поместить в пустоту, то сделаем пару первой
--а ее дочерней парой станет пустота
--иначе, будем пытаться сравнить ключи
-- совпали -- обновляем
-- если еще нет, то идем дальше
--либо поменяем, либо упремся в empty


--расширенная функция добавления листа пар в отображение
puts :: Eq k => Map k v -> [(k, v)] -> Map k v
puts m []  = m
puts m p = foldr (put) m p
--нечего объяснять, просто используем свертку от предыдущей функции


--функция удаления пары по ключу
remove :: Eq k => k -> Map k v -> Map k v
remove = remove'
  where
    remove' _ Empty = Empty
    remove' k (Map mk mv m)
      | k == mk = m
      | otherwise = Map mk mv (remove k m)
--из пустоты удалить ничего не можем
--иначе сравниваем с ключом
--совпало -- возращаем вместо простой пары дочернюю пару
--так как это односвязный лист, то мы удалили элемент
--не совпало -- запускаем функцию дальше

--функция, выдающая все ключи заданного отображения
keys :: Map k v -> [k]
keys = keys'
  where
    keys' Empty = []
    keys' (Map mk mv m) = mk : (keys' m)
--пока идем, забираем ключ, добавляем его в лист всех ключей
--дочернего отображения
--уперлись в пустоту = конец(начало)

--функция, находящая B\A
keysDifference :: Eq k => [k] -> [k] -> [k]
keysDifference xs ys = [ y | y <- ys,notIn y xs]
  where
    notIn y [] = True
    notIn y (x:xs)
      | y == x = False
      | otherwise = notIn y xs
--если элемент принадлежит только второму множеству, то он нам нужен
--другие -- нет

--функция, выдающая все значения заданного отображения
values :: Map k v -> [v]
values = values'
  where
    values' Empty = []
    values' (Map mk mv m) = mv : (values' m)
--идентична keys

--функция объединения двух отображений(с приоритетом к первому)
union :: Ord k => Map k a -> Map k a -> Map k a
union m1 Empty  = m1
union Empty m2 = m2
union m1 m2 = puts m1  ((gets (keysDifference (keys m1) (keys m2)) m2))
--если мы найдем все те ключи, которые есть во втором, но нет в первом
--потом выдадим по ним все пары
--а потом все новые пары поместим в первое отображение
--то мы получим объединения


--;;;CЛОЖНАЯ СТРУКТУРА ТЕСТОВ
--есть тесты трех видов test? test?1 testTrue?,где ? это 1 буква функции
--первый -- показывает результат действия функции из общего задания
--второй -- показывает результат дополнительных функций, которые
--понадобились для решения второго варианта
--третий ПРОВЕРЯЕТ(буллиановский массив) ожидание и реальность
--маленькие комментарии будут ко всем
--чтобы проверить только второй вариант testU1, testTrueU


--показывает обычное добавление
-- в пустоту
-- в саму себя же
-- в ручное представление
testP = [
    put (1,"aa") Empty,
    put (2,"bb") (put (1,"aa") Empty),
    put (2,"bb") (Map 1 "aa" Empty)
  ]
--показывает расширенное добавление
-- в пустоту
-- в себя же
-- добавление пустого листа
testP1 = [
    puts Empty [(1,'a'),(2,'b'),(3,'c')],
    puts (puts Empty [(2,'b'),(3,'c')]) [(1,'a')],
    puts (puts Empty [(1,'a'),(2,'b')]) []
  ]

--проверяем ассоциативность
--в разных видах
testTrueP = [
    put (2,"bb") (put (1,"aa") Empty) == put (2,"bb") (Map 1 "aa" Empty),
    puts Empty [(1,'a'),(2,'b'),(3,'c')] == puts (puts Empty [(2,'b'),(3,'c')]) [(1,'a')]
  ]

--показываем выдачу по ключу
--из пустоты
--если ключ есть
--если ключа нет
testG = [
    get 1 Empty,
    get 1 (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    get 4 (puts Empty [(1,'a'),(2,'a'),(3,'b')])
  ]

--показывает выдачу по листу ключей(+мэйбиТуЛист)
--из пустоты
--если все есть
--если каких-то ннет
--если всех нет
--если нет ключей
testG1 = [
    gets [1] Empty,
    gets [1,2] Empty,
    gets [1] (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    gets [2] (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    gets [1,4] (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    gets [1,2] (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    gets [4,5,6] (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    gets [] (puts Empty [(1,'a'),(2,'a'),(3,'b')])
  ]

--проверяем "линейность"
--показываем антиассоциативность
testTrueG = [
  gets [1] (puts Empty [(1,'a'),(2,'a'),(3,'b')])
    ++gets [2] (puts Empty [(1,'a'),(2,'a'),(3,'b')])
      == gets [1,2] (puts Empty [(2,'a'),(1,'a'),(3,'b')]),

  gets [1,2] (puts Empty [(1,'a'),(2,'a'),(3,'b')])
    /= gets [2,1](puts Empty [(1,'a'),(2,'a'),(3,'b')]),

  gets [1,4] (puts Empty [(1,'a'),(2,'a'),(3,'b')])
    == [(1,'a')]
  ]

--показывает удаление
--из пустоты
--если есть что удалить
--если удалить нечего
testR = [
    remove 1 Empty,
    remove 1 (puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    remove 1 (puts Empty [(2,'a'),(3,'b')])
  ]

--проверяем
--сохранность структуры отображения
--интересное свойство, показывающее, что если ничего
--не удалять разными способами, то ничего и не удалится :)
testTrueR = [
    remove 2 (puts Empty [(1,'a'),(2,'a'),(3,'b')])
      ==  puts Empty [(1,'a'),(3,'b')],
    remove 4 (puts Empty [(1,'a'),(2,'a'),(3,'b')])
      == remove 5 (puts Empty [(1,'a'),(2,'a'),(3,'b')])
  ]

--показывает получение ключей
--пустоты
--не пустоты
testK = [
    keys Empty,
    keys (puts Empty [(1,'a'),(2,'a'),(3,'b')])
  ]

--показывает B\A
--собственно B\A
--B\0
--0\B
--B\B
testK1 = [
    keysDifference (keys $ puts Empty [(1,'a'),(2,'a'),(3,'b')]) (keys $ puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    keysDifference (keys Empty) (keys $ puts Empty [(1,'a'),(2,'a'),(3,'b')]),
    keysDifference (keys $ puts Empty [(1,'a'),(2,'a'),(3,'b')]) (keys $ puts Empty [(3,'g'),(4,'g'),(5,'g')]),
    keysDifference (keys $ puts Empty [(1,'a'),(2,'a'),(3,'b')]) (keys Empty)
  ]

--наглядно показываем, что функция работает правильно
testTrueK = [
    keys  (puts Empty [(1,'a'),(2,'a'),(3,'b')]) == [3,2,1],
    keys  (puts Empty [(1,'a'),(4,'a'),(7,'b')]) == [7,4,1],
    keysDifference [3,2,1] [7,4,1] == [7,4]
  ]

--повторяет тесты keys
testV = [
    values Empty,
    values (puts Empty [(1,'a'),(2,'b'),(3,'c')])
  ]

 -- ...
testTrueV = [
    values (puts Empty [(1,'a'),(2,'b'),(3,'c')]) == "cba",
    values (puts Empty [(1,10),(2,20),(3,30)]) == [30,20,10]
  ]

--показывает, чему равны объединения с приоритетом 1 отображения
--просто двух отображений с пересечением
--когда первое пустое
--когда второе пустое
testU1 = [
    union (puts Empty [(1,'a'),(2,'b'),(3,'c')]) (puts Empty [(1,'d'),(4,'e'),(5,'f')]),
    union (Empty) (puts Empty [(1,'a'),(2,'b'),(3,'c')]),
    union (puts Empty [(1,'d'),(4,'e'),(5,'f')]) (Empty)
  ]

--проверяет, что операция объединения с приаритетом
-- не ассоциативна (кто бы мог подумать)
--проверяет тот самый приаритет
testTrueU = [
    not(union (puts Empty [(1,'a'),(2,'b'),(3,'c')]) (puts Empty [(1,'d'),(4,'e'),(5,'f')])
      == union (puts Empty [(1,'d'),(4,'e'),(5,'f')]) (puts Empty [(1,'a'),(2,'b'),(3,'c')])),

    union (puts Empty [(1,2),(2,3),(3,4)]) (puts Empty [(1,10),(2,20),(3,30)])
      == union (puts Empty [(1,2),(2,3),(3,4)]) (Empty)
  ]
